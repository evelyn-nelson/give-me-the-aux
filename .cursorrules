# Give Me The Aux - Cursor Rules

## Project Overview

This is a React Native (Expo) + Node.js music voting app where users create groups, submit Spotify songs based on themes, and vote on submissions. The app uses PostgreSQL with Prisma ORM and Spotify API for music integration.

## Tech Stack

- **Frontend**: Expo (React Native), TypeScript, React Navigation, TanStack Query, React Hook Form
- **Backend**: Node.js, Express, TypeScript, Prisma ORM, PostgreSQL
- **Database**: PostgreSQL (Docker container)
- **Authentication**: Spotify OAuth
- **Music Integration**: Spotify API
- **Infrastructure**: Docker, Docker Compose

## Project Structure

music-voting-app/
├── .env # Unified environment variables
├── docker-compose.yml # Docker services configuration
├── frontend/ # Expo React Native app
│ ├── app/ # Expo Router app directory
│ ├── components/ # Reusable UI components
│ ├── hooks/ # Custom React hooks
│ ├── services/ # API client functions
│ └── types/ # TypeScript type definitions
└── backend/ # Express.js API server
├── src/
│ ├── routes/ # API route handlers
│ ├── middleware/ # Express middleware
│ ├── services/ # Business logic
│ ├── utils/ # Utility functions
│ └── types/ # TypeScript types
└── prisma/
└── schema.prisma # Database schema

## Database Schema Context

Key models:

- **User**: Spotify OAuth, stores spotifyId, displayName, email
- **Group**: Has admin, configurable voting settings (submissionDurationDays, votingDurationDays, votesPerUserPerRound, maxVotesPerSong)
- **Round**: Belongs to group, has theme, description, and three phases (SUBMISSION, VOTING, COMPLETED)
- **Submission**: Song per user per round (spotifyTrackId, trackName, artistName, albumName)
- **Vote**: User can vote on submissions with count (points) and optional comment
- **Message**: Simple chat within groups

## Code Style & Conventions

### General

- Use TypeScript for all new code
- Prefer functional components and hooks
- Use async/await over promises
- Use meaningful variable and function names
- Add JSDoc comments for complex functions
- Do not add unnecessary comments

### Backend (Express + Prisma)

- Use Express Router for route organization
- Middleware pattern for authentication, validation, error handling
- Prisma Client for all database operations
- RESTful API design principles
- Error responses: `{ error: "message", code?: "ERROR_CODE" }`
- Success responses: `{ data: result }` or direct result for simple cases

### Frontend (Expo + React Native)

- Use Expo Router for navigation
- TanStack Query for API state management
- React Hook Form for form handling
- Functional components with hooks
- Custom hooks for reusable logic
- TypeScript interfaces for props and API responses

### File Naming

- **Components**: PascalCase (e.g., `GroupList.tsx`)
- **Hooks**: camelCase with "use" prefix (e.g., `useGroups.ts`)
- **API routes**: kebab-case (e.g., `user-groups.ts`)
- **Types**: PascalCase (e.g., `ApiResponse.ts`)

## API Patterns

### Authentication

- Use Spotify OAuth
- JWT tokens for session management
- Middleware: `requireAuth` for protected routes
- Store user info in req.user after auth

### Route Structure

/api/auth/spotify # Spotify OAuth
/api/auth/me # Current user info
/api/groups # CRUD for groups
/api/groups/:id/members # Group membership
/api/groups/:id/rounds # Rounds in group
/api/rounds/:id/submissions # Song submissions
/api/submissions/:id/votes # Voting on submissions
/api/groups/:id/messages # Group chat
/api/spotify/search # Spotify search proxy

### Error Handling

- Use try-catch in all async routes
- Return consistent error format
- Log errors server-side
- Handle Prisma errors gracefully

### Spotify Integration

- Proxy Spotify API calls through backend
- Cache track metadata in database
- Handle API quota limits gracefully
- Validate Spotify URLs/IDs

## Frontend Patterns

### API Calls

- Use TanStack Query for all API calls
- Custom hooks for each API endpoint
- Optimistic updates where appropriate
- Error boundaries for API failures

### State Management

- TanStack Query for server state
- React state for local UI state
- Context for global app state (user, theme)
- Avoid prop drilling

### Navigation

- Use Expo Router
- Type-safe navigation params
- Handle deep linking for group invites
- Proper loading states

### UI Components

- Reusable components in /components
- Props interfaces for all components
- Consistent spacing and styling
- Accessibility props (accessibilityLabel, etc.)

## Common Patterns

### Database Operations

```typescript
// Always use transactions for multi-table operations
await prisma.$transaction(async (tx) => {
  // operations
});

// Use include for relations
const group = await prisma.group.findUnique({
  where: { id },
  include: { members: true, rounds: true },
});
```

### API Response Handling

```typescript
// Backend
res.json({ data: result });

// Frontend
const { data, error, isLoading } = useQuery({
  queryKey: ["groups"],
  queryFn: () => api.getGroups(),
});
```

### Form Handling

```typescript
// Use React Hook Form
const {
  control,
  handleSubmit,
  formState: { errors },
} = useForm<FormData>();
```

## Environment Variables

All in root .env file:

- DATABASE_URL: PostgreSQL connection
- SPOTIFY_CLIENT_ID, SPOTIFY_CLIENT_SECRET: OAuth
- SPOTIFY_API_KEY: Spotify Web API
- JWT_SECRET: Token signing
- NODE_ENV: Environment

## Performance Considerations

- Use React.memo for expensive components
- Implement pagination for large lists
- Cache Spotify API responses
- Use database indexes for common queries
- Optimize bundle size with code splitting

## Security Guidelines

- Validate all user inputs
- Use parameterized queries (Prisma handles this)
- Implement rate limiting
- Sanitize user content
- Use HTTPS in production
- Secure JWT secret

## Development Workflow

1. Database schema changes: Update schema.prisma, run npx prisma db push
2. API changes: Update types, implement backend, update frontend
3. Use Docker for consistent development environment
4. Hot reloading enabled for both frontend and backend

## Common Commands

```bash
# Start development
docker-compose up

# Database operations
npx prisma db push
npx prisma studio

# Frontend
npx expo start
npx expo install package-name

# Backend
npm run dev
npm install package-name

# Generate Prisma client
docker compose --profile tools run --rm prisma generate

# Push database schema
docker compose --profile tools run --rm prisma db push

# Open Prisma Studio (optional)
docker compose --profile tools run --rm -p 5555:5555 prisma studio --hostname 0.0.0.0
```

When suggesting code:

1. Follow these patterns and conventions
2. Consider the full-stack context
3. Include proper TypeScript types
4. Handle errors appropriately
5. Use the established project structure
6. Consider mobile-first design for frontend
7. Ensure database operations are efficient
8. Include loading and error states
