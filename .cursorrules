# Give Me The Aux - Cursor Rules

## Project Overview

This is a React Native (Expo) + Node.js music voting app where users create groups, submit Spotify songs based on themes, and vote on submissions. The app uses PostgreSQL with Prisma ORM and Spotify API for music integration.

## Tech Stack

- **Frontend**: Expo (React Native), TypeScript, Expo Router, TanStack Query, React Hook Form
- **Backend**: Node.js, Express, TypeScript, Prisma ORM, PostgreSQL
- **Database**: PostgreSQL (Docker container)
- **Authentication**: Spotify OAuth
- **Music Integration**: Spotify API
- **Infrastructure**: Docker, Docker Compose

## Project Structure

music-voting-app/
├── .env # Unified environment variables
├── docker-compose.yml # Docker services configuration
├── frontend/ # Expo React Native app
│ ├── app/ # Expo Router app directory
│ ├── components/ # Reusable UI components
│ ├── hooks/ # Custom React hooks
│ ├── services/ # API client functions
│ └── types/ # TypeScript type definitions
└── backend/ # Express.js API server
├── src/
│ ├── routes/ # API route handlers
│ ├── middleware/ # Express middleware
│ ├── services/ # Business logic
│ ├── utils/ # Utility functions
│ └── types/ # TypeScript types
└── prisma/
└── schema.prisma # Database schema

## Database Schema Context

Key models:

- **User**: Spotify OAuth, stores spotifyId, displayName, email
- **Group**: Has admin, configurable voting settings (submissionDurationDays, votingDurationDays, votesPerUserPerRound, maxVotesPerSong)
- **Round**: Belongs to group, has theme, description, and three phases (SUBMISSION, VOTING, COMPLETED)
- **Submission**: Song per user per round (spotifyTrackId, trackName, artistName, albumName)
- **Vote**: User can vote on submissions with count (points) and optional comment
- **Message**: Simple chat within groups

## Code Style & Conventions

### General

- Use TypeScript for all new code
- Prefer functional components and hooks
- Use async/await over promises
- Use meaningful variable and function names
- Add JSDoc comments for complex functions
- Do not add unnecessary comments

### Backend (Express + Prisma)

- Use Express Router for route organization
- Middleware pattern for authentication, validation, error handling
- Prisma Client for all database operations
- RESTful API design principles
- Error responses: `{ error: "message", code?: "ERROR_CODE" }`
- Success responses: `{ data: result }` or direct result for simple cases

### Frontend (Expo + React Native)

- Use Expo Router for navigation
- TanStack Query for API state management
- React Hook Form for form handling
- Functional components with hooks
- Custom hooks for reusable logic
- TypeScript interfaces for props and API responses

### File Naming

- **Components**: PascalCase (e.g., `GroupList.tsx`)
- **Hooks**: camelCase with "use" prefix (e.g., `useGroups.ts`)
- **API routes**: kebab-case (e.g., `user-groups.ts`)
- **Types**: PascalCase (e.g., `ApiResponse.ts`)

## UI Design System

### Color Scheme

**Primary Colors:**

- `#191414` - Main background (dark almost black)
- `#282828` - Secondary background (cards, sections, inputs)
- `#FFB000` - Primary accent/brand color (golden yellow)
- `#404040` - Borders and dividers
- `#E53E3E` - Error states

**Text Colors:**

- `white` - Primary text
- `#B3B3B3` - Secondary text (descriptions, metadata)
- `#666666` - Muted text (placeholders, help text)
- `#999999` - Very muted text

**Usage Guidelines:**

- Use `#191414` for main app background
- Use `#282828` for cards, modals, and input backgrounds
- Use `#FFB000` for primary buttons, active states, and brand elements
- Use `white` for primary headings and important text
- Use `#B3B3B3` for secondary information
- Use `#404040` for borders (avoid shadows in favor of borders)

### Component Patterns

**Cards and Containers:**

```typescript
cardStyle: {
  backgroundColor: "#282828",
  borderRadius: 12,
  borderWidth: 1,
  borderColor: "#404040",
  padding: 16,
}
```

**Primary Buttons:**

```typescript
primaryButton: {
  backgroundColor: "#FFB000",
  paddingVertical: 14,
  borderRadius: 25,
  color: "#191414", // dark text on bright background
}
```

**Input Fields:**

```typescript
inputStyle: {
  backgroundColor: "#282828",
  borderWidth: 1,
  borderColor: "#404040",
  borderRadius: 8,
  color: "white",
  placeholderTextColor: "#666666",
}
```

**Text Hierarchy:**

- Headers: `color: "white", fontWeight: "600"`
- Body text: `color: "white", fontWeight: "400"`
- Secondary text: `color: "#B3B3B3"`
- Accent text: `color: "#FFB000"`

**Interactive Elements:**

- Navigation links: `#FFB000`
- Active states: `#FFB000`
- Disabled states: `opacity: 0.6`

## API Patterns

### Authentication

- Use Spotify OAuth
- JWT tokens for session management
- Middleware: `requireAuth` for protected routes
- Store user info in req.user after auth

### Route Structure

/api/auth/spotify # Spotify OAuth
/api/auth/me # Current user info
/api/groups # CRUD for groups
/api/groups/:id/members # Group membership
/api/groups/:id/rounds # Rounds in group
/api/rounds/:id/submissions # Song submissions
/api/submissions/:id/votes # Voting on submissions
/api/groups/:id/messages # Group chat
/api/spotify/search # Spotify search proxy

### Error Handling

- Use try-catch in all async routes
- Return consistent error format
- Log errors server-side
- Handle Prisma errors gracefully

### Spotify Integration

- Proxy Spotify API calls through backend
- Cache track metadata in database
- Handle API quota limits gracefully
- Validate Spotify URLs/IDs

## Frontend Patterns

### API Calls

- Use TanStack Query for all API calls
- Custom hooks for each API endpoint
- Optimistic updates where appropriate
- Error boundaries for API failures

### State Management

- TanStack Query for server state
- React state for local UI state
- Context for global app state (user, theme)
- Avoid prop drilling

### Navigation

- Use Expo Router (file-system routing) with the `frontend/app/` directory
- Create screens by adding route files; dynamic segments use square brackets, e.g., `app/group/[groupId].tsx`
- Programmatic navigation via `useRouter()` (`push`, `replace`, `back`)
- Read route params via `useLocalSearchParams()` and validate types
- Do not implement custom in-component navigators; rely on Router for back and gestures
- Deep linking is handled by Expo Router; prefer `router.push({ pathname, params })` for typed params
- Ensure `import 'react-native-gesture-handler'` exists in `frontend/index.ts`
- Safe areas: root `app/_layout.tsx` wraps the stack in `SafeAreaView`; avoid extra top padding in screens

### UI Components

- Reusable components in /components
- Props interfaces for all components
- Consistent spacing and styling
- Accessibility props (accessibilityLabel, etc.)

## Common Patterns

### Database Operations

```typescript
// Always use transactions for multi-table operations
await prisma.$transaction(async (tx) => {
  // operations
});

// Use include for relations
const group = await prisma.group.findUnique({
  where: { id },
  include: { members: true, rounds: true },
});
```

### API Response Handling

```typescript
// Backend
res.json({ data: result });

// Frontend
const { data, error, isLoading } = useQuery({
  queryKey: ["groups"],
  queryFn: () => api.getGroups(),
});
```

### Form Handling

```typescript
// Use React Hook Form
const {
  control,
  handleSubmit,
  formState: { errors },
} = useForm<FormData>();
```

## Environment Variables

All in root .env file:

- DATABASE_URL: PostgreSQL connection
- SPOTIFY_CLIENT_ID, SPOTIFY_CLIENT_SECRET: OAuth
- SPOTIFY_API_KEY: Spotify Web API
- JWT_SECRET: Token signing
- NODE_ENV: Environment

## Performance Considerations

- Use React.memo for expensive components
- Implement pagination for large lists
- Cache Spotify API responses
- Use database indexes for common queries
- Optimize bundle size with code splitting

## Security Guidelines

- Validate all user inputs
- Use parameterized queries (Prisma handles this)
- Implement rate limiting
- Sanitize user content
- Use HTTPS in production
- Secure JWT secret

## Development Workflow

1. Database schema changes: Update schema.prisma, run `npm run schema:update`
2. API changes: Update types, implement backend, update frontend
3. Use Docker for consistent development environment
4. Hot reloading enabled for both frontend and backend

## Schema Development Workflow

**CRITICAL**: Always use the automated scripts when changing Prisma schema to avoid TypeScript compilation errors and stale client types.

### For Schema Changes (Most Common)

```bash
npm run schema:update
```

**Use this when:** You've modified `backend/prisma/schema.prisma`

This script will:

- Stop the backend service to avoid conflicts
- Generate the new Prisma client
- Push schema changes to the database
- Regenerate the client (to pick up any DB changes)
- Restart the backend service
- Show you the logs

### For Quick Client Regeneration

```bash
npm run schema:generate
```

**Use this when:** You need to regenerate the Prisma client without schema changes

### If Scripts Don't Work (Nuclear Option)

```bash
npm run stop && npm run build:backend && npm run dev:backend
```

**Use this when:** The automated scripts fail, forces complete container rebuild

### Schema Change Best Practices

1. **Always use the scripts** - Don't run Prisma commands manually in containers
2. **Test after changes** - Check `npm run logs:backend` for compilation errors
3. **Atomic commits** - Commit schema + code changes together
4. **Document breaking changes** - Mention schema changes in PR descriptions

### Common Schema Issues & Solutions

- **"Object literal may only specify known properties"** → Run `npm run schema:update`
- **Backend container exits immediately** → Check `npm run logs:backend`, usually stale Prisma types
- **Database connection refused** → Run `npm run dev:backend` to start services
- **TypeScript errors persist** → Use nuclear option: rebuild container completely

### Schema Development Commands Quick Reference

| Command                   | Purpose                     | When to Use                  |
| ------------------------- | --------------------------- | ---------------------------- |
| `npm run schema:update`   | Full schema update workflow | After changing schema.prisma |
| `npm run schema:generate` | Quick client regeneration   | When client is out of sync   |
| `npm run build:backend`   | Rebuild backend container   | When scripts fail            |
| `npm run prisma:studio`   | Open database GUI           | Exploring/debugging data     |

## Common Commands

### Development & Services

```bash
# Start all services
npm run dev

# Start in background
npm run dev:detached

# Start just backend + database
npm run dev:backend

# Clean restart (when things are broken)
npm run dev:clean

# Stop services
npm run stop

# Stop and remove volumes (nuclear option)
npm run stop:all

# View logs
npm run logs
npm run logs:backend
npm run logs:postgres
```

### Schema & Database Operations

```bash
# SCHEMA CHANGES (Use this for schema.prisma changes)
npm run schema:update

# Quick client regeneration (no schema changes)
npm run schema:generate

# Individual Prisma operations (prefer scripts above)
npm run prisma:generate
npm run prisma:push
npm run prisma:studio
npm run prisma:reset

# Database seeding
npm run db:seed
```

### Container Management

```bash
# Rebuild containers
npm run build:backend
npm run build:all

# Shell access
npm run shell:backend
npm run shell:postgres
```

### Frontend (from frontend/ directory)

```bash
# Start Expo development server
npx expo start

# Install packages
npx expo install package-name
```

### Legacy Docker Commands (prefer npm scripts above)

```bash
# Only use these if npm scripts don't work
docker compose up
docker compose --profile tools run --rm prisma generate
docker compose --profile tools run --rm prisma db push
docker compose --profile tools run --rm -p 5555:5555 prisma studio --hostname 0.0.0.0
```

When suggesting code:

1. Follow these patterns and conventions
2. Consider the full-stack context
3. Include proper TypeScript types
4. Handle errors appropriately
5. Use the established project structure
6. Consider mobile-first design for frontend
7. Ensure database operations are efficient
8. Include loading and error states
9. **Use the established UI design system and color scheme**
10. Follow component patterns for consistent styling
