generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String         @id @default(cuid())
  spotifyId           String         @unique @map("spotify_id")
  displayName         String         @map("display_name")
  email               String         @unique
  avatarUrl           String?        @map("avatar_url")
  country             String?
  createdAt           DateTime       @default(now()) @map("created_at")
  spotifyAccessToken  String?        @map("spotify_access_token")
  spotifyRefreshToken String?        @map("spotify_refresh_token")
  spotifyTokenExpiry  DateTime?      @map("spotify_token_expiry")
  groupMemberships    GroupMember[]
  adminGroups         Group[]
  messages            Message[]
  playlists           Playlist[]
  refreshTokens       RefreshToken[]
  submissions         Submission[]
  votes               Vote[]
  groupInvitesCreated GroupInvite[]
  pushTokens          PushToken[]

  @@map("users")
}

model Group {
  id                     String        @id @default(cuid())
  name                   String
  adminId                String        @map("admin_id")
  submissionDurationDays Int           @default(3) @map("submission_duration_days")
  votingDurationDays     Int           @default(2) @map("voting_duration_days")
  votesPerUserPerRound   Int           @default(10) @map("votes_per_user_per_round")
  maxVotesPerSong        Int           @default(3) @map("max_votes_per_song")
  createdAt              DateTime      @default(now()) @map("created_at")
  members                GroupMember[]
  admin                  User          @relation(fields: [adminId], references: [id])
  messages               Message[]
  playlists              Playlist[]
  rounds                 Round[]
  invites                GroupInvite[]

  @@map("groups")
}

model GroupMember {
  groupId  String   @map("group_id")
  userId   String   @map("user_id")
  joinedAt DateTime @default(now()) @map("joined_at")
  group    Group    @relation(fields: [groupId], references: [id])
  user     User     @relation(fields: [userId], references: [id])

  @@id([groupId, userId])
  @@map("group_members")
}

model Round {
  id              String       @id @default(cuid())
  groupId         String       @map("group_id")
  theme           String
  description     String?
  startDate       DateTime     @map("start_date")
  endDate         DateTime     @map("end_date")
  votingStartDate DateTime     @map("voting_start_date")
  status          RoundStatus  @default(SUBMISSION)
  createdAt       DateTime     @default(now()) @map("created_at")
  order           Int          @default(1)
  playlists       Playlist[]
  group           Group        @relation(fields: [groupId], references: [id])
  submissions     Submission[]
  notificationEvents NotificationEvent[]

  @@unique([groupId, order])
  @@map("rounds")
}

model Submission {
  id             String   @id @default(cuid())
  roundId        String   @map("round_id")
  userId         String   @map("user_id")
  spotifyTrackId String   @map("spotify_track_id")
  trackName      String   @map("track_name")
  artistName     String   @map("artist_name")
  albumName      String   @map("album_name")
  imageUrl       String?  @map("image_url")
  previewUrl     String?  @map("preview_url")
  spotifyUrl     String   @map("spotify_url")
  comment        String?
  submittedAt    DateTime @default(now()) @map("submitted_at")
  round          Round    @relation(fields: [roundId], references: [id])
  user           User     @relation(fields: [userId], references: [id])
  votes          Vote[]

  @@unique([roundId, userId])
  @@map("submissions")
}

model Vote {
  id           String     @id @default(cuid())
  submissionId String     @map("submission_id")
  userId       String     @map("user_id")
  count        Int        @default(1)
  comment      String?
  isFinalized  Boolean    @default(false) @map("is_finalized")
  createdAt    DateTime   @default(now()) @map("created_at")
  submission   Submission @relation(fields: [submissionId], references: [id])
  user         User       @relation(fields: [userId], references: [id])

  @@unique([submissionId, userId])
  @@map("votes")
}

model Message {
  id        String   @id @default(cuid())
  groupId   String   @map("group_id")
  userId    String   @map("user_id")
  content   String
  createdAt DateTime @default(now()) @map("created_at")
  group     Group    @relation(fields: [groupId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@map("messages")
}

model Playlist {
  id        String         @id @default(cuid())
  name      String
  userId    String         @map("user_id")
  groupId   String?        @map("group_id")
  roundId   String?        @map("round_id")
  type      PlaylistType   @default(CUSTOM)
  isPublic  Boolean        @default(false) @map("is_public")
  createdAt DateTime       @default(now()) @map("created_at")
  items     PlaylistItem[]
  group     Group?         @relation(fields: [groupId], references: [id])
  round     Round?         @relation(fields: [roundId], references: [id])
  user      User           @relation(fields: [userId], references: [id])
  spotifyPlaylistId String? @unique @map("spotify_playlist_id")
  spotifyUrl       String?  @map("spotify_url")

  @@map("playlists")
}

model PlaylistItem {
  id             String   @id @default(cuid())
  playlistId     String   @map("playlist_id")
  spotifyTrackId String   @map("spotify_track_id")
  trackName      String   @map("track_name")
  artistName     String   @map("artist_name")
  albumName      String   @map("album_name")
  imageUrl       String?  @map("image_url")
  order          Int
  addedAt        DateTime @default(now()) @map("added_at")
  playlist       Playlist @relation(fields: [playlistId], references: [id])

  @@map("playlist_items")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String   @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  isRevoked Boolean  @default(false) @map("is_revoked")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model GroupInvite {
  id              String   @id @default(cuid())
  token           String   @unique
  groupId         String   @map("group_id")
  createdByUserId String   @map("created_by_user_id")
  expiresAt       DateTime? @map("expires_at")
  maxUses         Int?     @map("max_uses")
  usedCount       Int      @default(0) @map("used_count")
  isRevoked       Boolean  @default(false) @map("is_revoked")
  createdAt       DateTime @default(now()) @map("created_at")
  group           Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  createdBy       User     @relation(fields: [createdByUserId], references: [id])

  @@map("group_invites")
}

model PushToken {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  token      String   @unique
  platform   String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  lastUsedAt DateTime? @map("last_used_at")
  isRevoked  Boolean  @default(false) @map("is_revoked")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("push_tokens")
}

model NotificationEvent {
  id      String            @id @default(cuid())
  roundId String            @map("round_id")
  type    NotificationType
  sentAt  DateTime?         @map("sent_at")
  round   Round             @relation(fields: [roundId], references: [id], onDelete: Cascade)

  @@unique([roundId, type])
  @@map("notification_events")
}

enum RoundStatus {
  SUBMISSION
  VOTING
  COMPLETED
  INACTIVE
}

enum PlaylistType {
  CUSTOM
  ROUND_WINNERS
  ROUND_ALL
  USER_SUBMISSIONS
  USER_VOTES
}

enum NotificationType {
  SUBMISSION_ENDING_SOON
  VOTING_STARTED
  VOTING_ENDING_SOON
  VOTING_ENDED
}
